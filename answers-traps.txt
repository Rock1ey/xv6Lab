Q1: Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?
A: 函数参数的寄存器为 a0~a7，printf 的 13 存在寄存器 a2 中。

Q2: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
A: 在main函数中调用printf时调用了f函数，而f函数中又调用了g函数，但在这之后的第二行（第40行）可以看到, 编译器直接将f(8)+1的值12计算出来了，说明编译器进行了函数内联。

Q3: At what address is the function printf located?
A: 由第 43 和 44 行可以看出, 跳转之前ra的值为30,而jalr跳转指令的1510(ra)表示跳转的地址为0x30+1510=0x616, 即函数 printf 的地址为 0x616。

Q4: What value is in the register ra just after the jalr to printf in main?
A: 由44-46行可看出，跳转指令执行时ra中的值为0x34，而跳转后PC的值+4,故在跳转指令之后ra中的值为0x38。

Q5: Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set to in order to yield the same output? Would you need to change to a different value?i57616

Here's a description of little- and big-endian and a more whimsical description.

A:若为大端对齐, i 需要设置为 0x726c6400, 不需要改变 57616的值(因为他是按照二进制数字读取的而非单个字符)。

Q6: In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? 'y='

	printf("x=%d y=%d", 3);
	
A: 根据函数的传参规则, y= 后跟的值应该为寄存器 a2 的值.
如图所示, 经过 gdb 调试验证, y= 后确实是寄存器 a2 的值.
这种情况发生的原因在于, printf() 的格式字符串的数量和不定参数的数量不一致, 但函数执行时仍然从原本参数应该加载的寄存器取值. 按照 RISC-V 传参规则, 第二个不定参数应该被存于寄存器 a2, 因此在实际输出时也是将 a2 寄存器的值进行输出.
